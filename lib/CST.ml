(* Generated by ocaml-tree-sitter. *)
(*
   circom grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type signal_visability = [
    `Input of Token.t (* "input" *)
  | `Output of Token.t (* "output" *)
]

type escape_sequence = Token.t

type int_ = Token.t (* pattern \d+ *)

type identifier = Token.t (* pattern [a-zA-Z$_][a-zA-Z0-9$_]* *)

type circom_version =
  Token.t (* pattern "\"?\\.? ?(\\d|\\*\
  )+(\\. ?(\\d|\\*\
  )+ ?(\\.(\\d|\\*\
  )+)?)?\"?" *)

type string_immediate_elt_inside_double_quote =
  Token.t (* pattern "[^\"\\\\\\n]+|\\\\\\r?\\n" *)

type string_immediate_elt_inside_quote =
  Token.t (* pattern "[^'\\\\\\n]+|\\\\\\r?\\n" *)

type parameter = [
    `Id of identifier (*tok*)
  | `Ellips of Token.t (* "..." *)
]

type signal_tags = (
    Token.t (* "{" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * Token.t (* "}" *)
)

type circom_pragma_token = [
    `Circom_circom_vers of (Token.t (* "circom" *) * circom_version (*tok*))
  | `Circom_id of (Token.t (* "circom" *) * identifier (*tok*))
]

type template_type = [
    `Custom of Token.t (* "custom" *)
  | `Para of Token.t (* "parallel" *)
]

type anon_choice_id_3723479 = [
    `Id of identifier (*tok*)
  | `Member_exp of member_expression
  | `Array_access_exp of array_access_expression
]

and anonymous_inputs = (
    Token.t (* "(" *)
  * argument_list option
  * Token.t (* ")" *)
)

and argument_list = (
    expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
)

and array_ = (
    Token.t (* "[" *)
  * expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and array_access_expression = (
    expression
  * Token.t (* "[" *)
  * expression option
  * Token.t (* "]" *)
)

and assignment_expression = (
    [ `Exp of expression ]
  * [
        `LTEQEQ of Token.t (* "<==" *)
      | `EQEQGT of Token.t (* "==>" *)
      | `LTDASHDASH of Token.t (* "<--" *)
      | `DASHDASHGT of Token.t (* "-->" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `STARSTAREQ of Token.t (* "**=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `BSLASHEQ of Token.t (* "\\=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `EQEQEQ of Token.t (* "===" *)
      | `EQ of Token.t (* "=" *)
    ]
  * expression
)

and binary_expression = [
    `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_BSLASH_exp of (expression * Token.t (* "\\" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_STARSTAR_exp of (expression * Token.t (* "**" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
]

and call_expression = (
    Token.t (* "parallel" *) option
  * identifier (*tok*)
  * Token.t (* "(" *)
  * argument_list option
  * Token.t (* ")" *)
  * anonymous_inputs option
)

and decrement_expression = (anon_choice_id_3723479 * Token.t (* "--" *))

and expression = [
    `Choice_int of [
        `Int of int_ (*tok*)
      | `Id of identifier (*tok*)
      | `Array of array_
      | `Tuple of tuple
      | `Un_exp of unary_expression
      | `Bin_exp of binary_expression
      | `Tern_exp of ternary_expression
      | `Paren_exp of parenthesized_expression
      | `Call_exp of call_expression
      | `Incr_exp of increment_expression
      | `Decr_exp of decrement_expression
      | `Member_exp of member_expression
      | `Array_access_exp of array_access_expression
      | `Assign_exp of assignment_expression
    ]
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of (
        Token.t (* "<..." *) * expression * Token.t (* "...>" *)
    )
]

and increment_expression = (anon_choice_id_3723479 * Token.t (* "++" *))

and member_expression = (
    [ `Exp of expression | `Id of identifier (*tok*) ]
  * Token.t (* "." *)
  * identifier (*tok*)
)

and parenthesized_expression = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and ternary_expression = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)

and tuple = (
    Token.t (* "(" *)
  * expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and unary_expression = [
    `BANG_exp of (Token.t (* "!" *) * expression)
  | `TILDE_exp of (Token.t (* "~" *) * expression)
  | `DASH_exp of (Token.t (* "-" *) * expression)
  | `PLUS_exp of (Token.t (* "+" *) * expression)
]

type string_ = [
    `DQUOT_rep_choice_str_imme_elt_inside_double_quote_DQUOT of (
        Token.t (* "\"" *)
      * [
            `Str_imme_elt_inside_double_quote of
              string_immediate_elt_inside_double_quote (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `SQUOT_rep_choice_str_imme_elt_inside_quote_SQUOT of (
        Token.t (* "'" *)
      * [
            `Str_imme_elt_inside_quote of
              string_immediate_elt_inside_quote (*tok*)
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "'" *)
    )
]

type parameter_list = (
    Token.t (* "(" *)
  * (
        parameter
      * (Token.t (* "," *) * parameter) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ")" *)
)

type main_component_public_signals = (
    Token.t (* "{" *)
  * Token.t (* "public" *)
  * Token.t (* "[" *)
  * parameter
  * (Token.t (* "," *) * parameter) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
  * Token.t (* "}" *)
)

type expression_statement = [
    `Exp_semi of (expression * Token.t (* ";" *))
  | `Ellips_SEMI of (Token.t (* "..." *) * Token.t (* ";" *))
  | `Ellips of Token.t (* "..." *)
]

type array_definition =
  (Token.t (* "[" *) * expression * Token.t (* "]" *)) list (* one or more *)

type type_ = [
    `Signal of (
        Token.t (* "signal" *)
      * signal_visability option
      * signal_tags option
    )
  | `Var of Token.t (* "var" *)
  | `Comp of Token.t (* "component" *)
]

type variable_initialization = (
    identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * Token.t (* "," *) option
  * array_definition option
  * (
        [
            `EQ of Token.t (* "=" *)
          | `LTEQEQ of Token.t (* "<==" *)
          | `EQEQGT of Token.t (* "==>" *)
          | `LTDASHDASH of Token.t (* "<--" *)
          | `DASHDASHGT of Token.t (* "-->" *)
        ]
      * expression
    )
      option
)

type directive = [
    `Pragma_dire of (
        Token.t (* "pragma" *)
      * [
            `Circom_pragma_tok of circom_pragma_token
          | `Circom_custom_templs_tok of Token.t (* "custom_templates" *)
        ]
      * Token.t (* ";" *)
    )
  | `Incl_dire of (Token.t (* "include" *) * string_ * Token.t (* ";" *))
]

type variable_declaration_statement = (
    type_
  * variable_initialization
  * (Token.t (* "," *) * variable_initialization) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ";" *)
)

type for_statement = [
    `For_LPAR_choice_var_decl_stmt_choice_exp_stmt_opt_exp_RPAR_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Var_decl_stmt of variable_declaration_statement
          | `Exp_stmt of expression_statement
          | `Semi of Token.t (* ";" *)
        ]
      * [ `Exp_stmt of expression_statement | `Semi of Token.t (* ";" *) ]
      * expression option
      * Token.t (* ")" *)
      * statement
    )
  | `For_LPAR_ellips_RPAR_stmt of (
        Token.t (* "for" *) * Token.t (* "(" *) * Token.t (* "..." *)
      * Token.t (* ")" *) * statement
    )
]

and statement = [
    `Ret_stmt of (Token.t (* "return" *) * expression * Token.t (* ";" *))
  | `Blk_stmt of (
        Token.t (* "{" *)
      * statement list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `If_stmt of (
        Token.t (* "if" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* ")" *)
      * statement
      * (Token.t (* "else" *) * statement) option
    )
  | `For_stmt of for_statement
  | `While_stmt of (
        Token.t (* "while" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *) * statement
    )
  | `Var_decl_stmt of variable_declaration_statement
  | `Exp_stmt of expression_statement
]

type function_body = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

type template_body = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

type definition = [
    `Func_defi of (
        Token.t (* "function" *) * identifier (*tok*) * parameter_list
      * function_body
    )
  | `Temp_defi of (
        Token.t (* "template" *)
      * template_type option
      * identifier (*tok*)
      * parameter_list
      * template_body
    )
  | `Main_comp_defi of (
        Token.t (* "component" *)
      * Token.t (* "main" *)
      * main_component_public_signals option
      * Token.t (* "=" *)
      * call_expression
      * Token.t (* ";" *)
    )
]

type source_unit = [ `Dire of directive | `Defi of definition ]

type source_file = [
    `Rep_source_unit of source_unit list (* zero or more *)
  | `Rep1_stmt of statement list (* one or more *)
  | `Exp of expression
]

type circom_custom_templates_token (* inlined *) =
  Token.t (* "custom_templates" *)

type ellipsis (* inlined *) = Token.t (* "..." *)

type component (* inlined *) = Token.t (* "component" *)

type circom (* inlined *) = Token.t (* "circom" *)

type custom (* inlined *) = Token.t (* "custom" *)

type var (* inlined *) = Token.t (* "var" *)

type semicolon (* inlined *) = Token.t (* ";" *)

type parallel (* inlined *) = Token.t (* "parallel" *)

type comment (* inlined *) = Token.t

type deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

type signal (* inlined *) = (
    Token.t (* "signal" *)
  * signal_visability option
  * signal_tags option
)

type pragma_directive (* inlined *) = (
    Token.t (* "pragma" *)
  * [
        `Circom_pragma_tok of circom_pragma_token
      | `Circom_custom_templs_tok of Token.t (* "custom_templates" *)
    ]
  * Token.t (* ";" *)
)

type return_statement (* inlined *) = (
    Token.t (* "return" *) * expression * Token.t (* ";" *)
)

type include_directive (* inlined *) = (
    Token.t (* "include" *) * string_ * Token.t (* ";" *)
)

type main_component_definition (* inlined *) = (
    Token.t (* "component" *)
  * Token.t (* "main" *)
  * main_component_public_signals option
  * Token.t (* "=" *)
  * call_expression
  * Token.t (* ";" *)
)

type block_statement (* inlined *) = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
  * statement
  * (Token.t (* "else" *) * statement) option
)

type while_statement (* inlined *) = (
    Token.t (* "while" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *) * statement
)

type function_definition (* inlined *) = (
    Token.t (* "function" *) * identifier (*tok*) * parameter_list
  * function_body
)

type template_definition (* inlined *) = (
    Token.t (* "template" *)
  * template_type option
  * identifier (*tok*)
  * parameter_list
  * template_body
)

type extra = [ `Comment of Loc.t * comment ]

type extras = extra list

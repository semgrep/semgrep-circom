(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_circom"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "int", None;
  "circom_custom_templates_token", None;
  "string_immediate_elt_inside_double_quote", None;
  "escape_sequence", None;
  "component", None;
  "circom", None;
  "identifier", None;
  "semicolon", None;
  "ellipsis", None;
  "string_immediate_elt_inside_quote", None;
  "circom_version", None;
  "signal_visability",
  Some (
    Alt [|
      Token (Literal "input");
      Token (Literal "output");
    |];
  );
  "var", None;
  "template_type",
  Some (
    Alt [|
      Token (Literal "custom");
      Token (Literal "parallel");
    |];
  );
  "parameter_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "identifier");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "identifier");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "signal_tags",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
      Token (Literal "}");
    ];
  );
  "main_component_public_signals",
  Some (
    Seq [
      Token (Literal "{");
      Token (Literal "public");
      Token (Literal "[");
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
      Token (Literal "}");
    ];
  );
  "argument_list",
  Some (
    Seq [
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
    ];
  );
  "array",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "array_access_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "[");
      Opt (
        Token (Name "expression");
      );
      Token (Literal "]");
    ];
  );
  "assignment_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "expression");
      |];
      Alt [|
        Token (Literal "<==");
        Token (Literal "==>");
        Token (Literal "<--");
        Token (Literal "-->");
        Token (Literal "&=");
        Token (Literal "+=");
        Token (Literal "-=");
        Token (Literal "*=");
        Token (Literal "**=");
        Token (Literal "/=");
        Token (Literal "\\=");
        Token (Literal "%=");
        Token (Literal "|=");
        Token (Literal "^=");
        Token (Literal ">>=");
        Token (Literal "<<=");
        Token (Literal "===");
        Token (Literal "=");
      |];
      Token (Name "expression");
    ];
  );
  "binary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal "&&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "||");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "|");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "^");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "*");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "/");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "\\");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "%");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "**");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "==");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">");
        Token (Name "expression");
      ];
    |];
  );
  "call_expression",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "(");
      Opt (
        Token (Name "argument_list");
      );
      Token (Literal ")");
    ];
  );
  "decrement_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "member_expression");
        Token (Name "array_access_expression");
      |];
      Token (Literal "--");
    ];
  );
  "deep_ellipsis",
  Some (
    Seq [
      Token (Literal "<...");
      Token (Name "expression");
      Token (Literal "...>");
    ];
  );
  "expression",
  Some (
    Alt [|
      Alt [|
        Token (Name "int");
        Token (Name "identifier");
        Token (Name "array");
        Token (Name "unary_expression");
        Token (Name "binary_expression");
        Token (Name "ternary_expression");
        Token (Name "parenthesized_expression");
        Token (Name "call_expression");
        Token (Name "increment_expression");
        Token (Name "decrement_expression");
        Token (Name "member_expression");
        Token (Name "array_access_expression");
        Token (Name "assignment_expression");
      |];
      Token (Name "ellipsis");
      Token (Name "deep_ellipsis");
    |];
  );
  "increment_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "member_expression");
        Token (Name "array_access_expression");
      |];
      Token (Literal "++");
    ];
  );
  "member_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "expression");
        Token (Name "identifier");
      |];
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "ternary_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "unary_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "!");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "~");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "+");
        Token (Name "expression");
      ];
    |];
  );
  "string",
  Some (
    Alt [|
      Seq [
        Token (Literal "\"");
        Repeat (
          Alt [|
            Token (Name "string_immediate_elt_inside_double_quote");
            Token (Name "escape_sequence");
          |];
        );
        Token (Literal "\"");
      ];
      Seq [
        Token (Literal "'");
        Repeat (
          Alt [|
            Token (Name "string_immediate_elt_inside_quote");
            Token (Name "escape_sequence");
          |];
        );
        Token (Literal "'");
      ];
    |];
  );
  "circom_pragma_token",
  Some (
    Seq [
      Token (Name "circom");
      Token (Name "circom_version");
    ];
  );
  "signal",
  Some (
    Seq [
      Token (Literal "signal");
      Opt (
        Token (Name "signal_visability");
      );
      Opt (
        Token (Name "signal_tags");
      );
    ];
  );
  "array_definition",
  Some (
    Repeat1 (
      Seq [
        Token (Literal "[");
        Token (Name "expression");
        Token (Literal "]");
      ];
    );
  );
  "return_statement",
  Some (
    Seq [
      Token (Literal "return");
      Token (Name "expression");
      Token (Name "semicolon");
    ];
  );
  "expression_statement",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Name "semicolon");
      ];
      Seq [
        Token (Name "ellipsis");
        Token (Literal ";");
      ];
      Token (Name "ellipsis");
    |];
  );
  "main_component_definition",
  Some (
    Seq [
      Token (Literal "component");
      Token (Literal "main");
      Opt (
        Token (Name "main_component_public_signals");
      );
      Token (Literal "=");
      Token (Name "call_expression");
      Token (Name "semicolon");
    ];
  );
  "include_directive",
  Some (
    Seq [
      Token (Literal "include");
      Token (Name "string");
      Token (Name "semicolon");
    ];
  );
  "pragma_directive",
  Some (
    Seq [
      Token (Literal "pragma");
      Alt [|
        Token (Name "circom_pragma_token");
        Token (Name "circom_custom_templates_token");
      |];
      Token (Name "semicolon");
    ];
  );
  "type",
  Some (
    Alt [|
      Token (Name "signal");
      Token (Name "var");
      Token (Name "component");
    |];
  );
  "variable_initialization",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Opt (
        Token (Name "array_definition");
      );
      Opt (
        Seq [
          Alt [|
            Token (Literal "=");
            Token (Literal "<==");
            Token (Literal "==>");
            Token (Literal "<--");
            Token (Literal "-->");
          |];
          Token (Name "expression");
        ];
      );
    ];
  );
  "directive",
  Some (
    Alt [|
      Token (Name "pragma_directive");
      Token (Name "include_directive");
    |];
  );
  "variable_declaration_statement",
  Some (
    Seq [
      Token (Name "type");
      Token (Name "variable_initialization");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "variable_initialization");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Name "semicolon");
    ];
  );
  "block_statement",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "for_statement",
  Some (
    Alt [|
      Seq [
        Token (Literal "for");
        Token (Literal "(");
        Alt [|
          Token (Name "variable_declaration_statement");
          Token (Name "expression_statement");
          Token (Name "semicolon");
        |];
        Alt [|
          Token (Name "expression_statement");
          Token (Name "semicolon");
        |];
        Opt (
          Token (Name "expression");
        );
        Token (Literal ")");
        Token (Name "statement");
      ];
      Seq [
        Token (Literal "for");
        Token (Literal "(");
        Token (Name "ellipsis");
        Token (Literal ")");
        Token (Name "statement");
      ];
    |];
  );
  "if_statement",
  Some (
    Seq [
      Token (Literal "if");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "statement");
        ];
      );
    ];
  );
  "statement",
  Some (
    Alt [|
      Token (Name "return_statement");
      Token (Name "block_statement");
      Token (Name "if_statement");
      Token (Name "for_statement");
      Token (Name "while_statement");
      Token (Name "variable_declaration_statement");
      Token (Name "expression_statement");
    |];
  );
  "while_statement",
  Some (
    Seq [
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "function_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "template_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "function_definition",
  Some (
    Seq [
      Token (Literal "function");
      Token (Name "identifier");
      Token (Name "parameter_list");
      Token (Name "function_body");
    ];
  );
  "template_definition",
  Some (
    Seq [
      Token (Literal "template");
      Opt (
        Token (Name "template_type");
      );
      Token (Name "identifier");
      Token (Name "parameter_list");
      Token (Name "template_body");
    ];
  );
  "definition",
  Some (
    Alt [|
      Token (Name "function_definition");
      Token (Name "template_definition");
      Token (Name "main_component_definition");
    |];
  );
  "source_unit",
  Some (
    Alt [|
      Token (Name "directive");
      Token (Name "definition");
    |];
  );
  "source_file",
  Some (
    Alt [|
      Seq [
        Repeat (
          Token (Name "source_unit");
        );
      ];
      Repeat1 (
        Token (Name "statement");
      );
      Token (Name "expression");
    |];
  );
]

let trans_int_ ((kind, body) : mt) : CST.int_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_circom_custom_templates_token ((kind, body) : mt) : CST.circom_custom_templates_token =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_immediate_elt_inside_double_quote ((kind, body) : mt) : CST.string_immediate_elt_inside_double_quote =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_component ((kind, body) : mt) : CST.component =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_circom ((kind, body) : mt) : CST.circom =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semicolon ((kind, body) : mt) : CST.semicolon =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ellipsis ((kind, body) : mt) : CST.ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_immediate_elt_inside_quote ((kind, body) : mt) : CST.string_immediate_elt_inside_quote =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_circom_version ((kind, body) : mt) : CST.circom_version =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_signal_visability ((kind, body) : mt) : CST.signal_visability =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Input (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Output (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_var ((kind, body) : mt) : CST.var =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_template_type ((kind, body) : mt) : CST.template_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Custom (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Para (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_parameter_list ((kind, body) : mt) : CST.parameter_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_identifier (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_identifier (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_signal_tags ((kind, body) : mt) : CST.signal_tags =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_main_component_public_signals ((kind, body) : mt) : CST.main_component_public_signals =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v5
            ,
            Run.trans_token (Run.matcher_token v6),
            Run.trans_token (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_ ((kind, body) : mt) : CST.array_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_access_expression ((kind, body) : mt) : CST.array_access_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment_expression ((kind, body) : mt) : CST.assignment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `LTEQEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `EQEQGT (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `LTDASHDASH (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `DASHDASHGT (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `AMPEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `PLUSEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `DASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `STAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `STARSTAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `SLASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `BSLASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `PERCEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (12, v) ->
                `BAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (13, v) ->
                `HATEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (14, v) ->
                `GTGTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (15, v) ->
                `LTLTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (16, v) ->
                `EQEQEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (17, v) ->
                `EQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_AMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_BAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_GTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Exp_LTLT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Exp_HAT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Exp_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Exp_DASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Exp_STAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Exp_SLASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Exp_BSLASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Exp_PERC_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Exp_STARSTAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Exp_LT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Exp_LTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `Exp_EQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `Exp_BANGEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (18, v) ->
          `Exp_GTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (19, v) ->
          `Exp_GT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_expression ((kind, body) : mt) : CST.call_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_argument_list (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_decrement_expression ((kind, body) : mt) : CST.decrement_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Member_exp (
                  trans_member_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Array_access_exp (
                  trans_array_access_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_deep_ellipsis ((kind, body) : mt) : CST.deep_ellipsis =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_int (
            (match v with
            | Alt (0, v) ->
                `Int (
                  trans_int_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Array (
                  trans_array_ (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Un_exp (
                  trans_unary_expression (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Bin_exp (
                  trans_binary_expression (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Tern_exp (
                  trans_ternary_expression (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Paren_exp (
                  trans_parenthesized_expression (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Call_exp (
                  trans_call_expression (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `Incr_exp (
                  trans_increment_expression (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `Decr_exp (
                  trans_decrement_expression (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `Member_exp (
                  trans_member_expression (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `Array_access_exp (
                  trans_array_access_expression (Run.matcher_token v)
                )
            | Alt (12, v) ->
                `Assign_exp (
                  trans_assignment_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Deep_ellips (
            trans_deep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_increment_expression ((kind, body) : mt) : CST.increment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Member_exp (
                  trans_member_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Array_access_exp (
                  trans_array_access_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_member_expression ((kind, body) : mt) : CST.member_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ternary_expression ((kind, body) : mt) : CST.ternary_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `BANG_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `TILDE_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `DASH_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `PLUS_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DQUOT_rep_choice_str_imme_elt_inside_double_quote_DQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Str_imme_elt_inside_double_quote (
                            trans_string_immediate_elt_inside_double_quote (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Esc_seq (
                            trans_escape_sequence (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `SQUOT_rep_choice_str_imme_elt_inside_quote_SQUOT (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Str_imme_elt_inside_quote (
                            trans_string_immediate_elt_inside_quote (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Esc_seq (
                            trans_escape_sequence (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_circom_pragma_token ((kind, body) : mt) : CST.circom_pragma_token =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_circom (Run.matcher_token v0),
            trans_circom_version (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_signal ((kind, body) : mt) : CST.signal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_signal_visability (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_signal_tags (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_array_definition ((kind, body) : mt) : CST.array_definition =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Seq [v0; v1; v2] ->
              (
                Run.trans_token (Run.matcher_token v0),
                trans_expression (Run.matcher_token v1),
                Run.trans_token (Run.matcher_token v2)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_expression_statement ((kind, body) : mt) : CST.expression_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_semi (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  trans_semicolon (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips_SEMI (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_ellipsis (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_main_component_definition ((kind, body) : mt) : CST.main_component_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                trans_main_component_public_signals (Run.matcher_token v)
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_call_expression (Run.matcher_token v4),
            trans_semicolon (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_include_directive ((kind, body) : mt) : CST.include_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_string_ (Run.matcher_token v1),
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pragma_directive ((kind, body) : mt) : CST.pragma_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Circom_pragma_tok (
                  trans_circom_pragma_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Circom_custom_templs_tok (
                  trans_circom_custom_templates_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_semicolon (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Signal (
            trans_signal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Var (
            trans_var (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Comp (
            trans_component (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variable_initialization ((kind, body) : mt) : CST.variable_initialization =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_array_definition (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `EQ (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `LTEQEQ (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `EQEQGT (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `LTDASHDASH (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (4, v) ->
                          `DASHDASHGT (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_directive ((kind, body) : mt) : CST.directive =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pragma_dire (
            trans_pragma_directive (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Incl_dire (
            trans_include_directive (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variable_declaration_statement ((kind, body) : mt) : CST.variable_declaration_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_type_ (Run.matcher_token v0),
            trans_variable_initialization (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_variable_initialization (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            trans_semicolon (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_block_statement ((kind, body) : mt) : CST.block_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `For_LPAR_choice_var_decl_stmt_choice_exp_stmt_opt_exp_RPAR_stmt (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Var_decl_stmt (
                        trans_variable_declaration_statement (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Exp_stmt (
                        trans_expression_statement (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Semi (
                        trans_semicolon (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  (match v3 with
                  | Alt (0, v) ->
                      `Exp_stmt (
                        trans_expression_statement (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Semi (
                        trans_semicolon (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v -> trans_expression (Run.matcher_token v))
                    v4
                  ,
                  Run.trans_token (Run.matcher_token v5),
                  trans_statement (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `For_LPAR_ellips_RPAR_stmt (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_ellipsis (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_statement (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_statement (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Ret_stmt (
            trans_return_statement (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Blk_stmt (
            trans_block_statement (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `If_stmt (
            trans_if_statement (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `For_stmt (
            trans_for_statement (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `While_stmt (
            trans_while_statement (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Var_decl_stmt (
            trans_variable_declaration_statement (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Exp_stmt (
            trans_expression_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_body ((kind, body) : mt) : CST.function_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_template_body ((kind, body) : mt) : CST.template_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_definition ((kind, body) : mt) : CST.function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_parameter_list (Run.matcher_token v2),
            trans_function_body (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_template_definition ((kind, body) : mt) : CST.template_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_template_type (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            trans_parameter_list (Run.matcher_token v3),
            trans_template_body (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_definition ((kind, body) : mt) : CST.definition =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Func_defi (
            trans_function_definition (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Temp_defi (
            trans_template_definition (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Main_comp_defi (
            trans_main_component_definition (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_unit ((kind, body) : mt) : CST.source_unit =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Dire (
            trans_directive (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Defi (
            trans_definition (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rep_source_unit (
            (match v with
            | Seq [v0] ->
                (
                  Run.repeat
                    (fun v -> trans_source_unit (Run.matcher_token v))
                    v0
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Rep1_stmt (
            Run.repeat1
              (fun v -> trans_statement (Run.matcher_token v))
              v
          )
      | Alt (2, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_source_file matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

